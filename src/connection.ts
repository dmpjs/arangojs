/*
 * Copyright (C) Copyright 2015 ArangoDB GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Modifications copyright (C) 2020 Daniel Bannert
 */

/**
 * The "connection" module provides connection and configuration related types
 * for TypeScript.
 *
 * @packageDocumentation
 */
import { Querystring } from "./lib/querystring.ts";
import { Database } from "./database.ts";
import { ArangoError, HttpError, isSystemError } from "./error.ts";
import { Errback } from "./types/errback.ts";
import {
  ArangojsResponse,
  RequestFunction,
} from "./types/request.ts";
import { createRequest } from "./lib/create_request.ts";
import { sanitizeUrl } from "./lib/sanitize_url.ts";

const MIME_JSON = /\/(json|javascript)(\W|$)/;
const LEADER_ENDPOINT_HEADER = "x-arango-endpoint";

/**
 * Determines the behavior when multiple URLs are used:
 *
 * - `"NONE"`: No load balancing. All requests will be handled by the first
 *   URL in the list until a network error is encountered. On network error,
 *   arangojs will advance to using the next URL in the list.
 *
 * - `"ONE_RANDOM"`: Randomly picks one URL from the list initially, then
 *   behaves like `"NONE"`.
 *
 * - `"ROUND_ROBIN"`: Every sequential request uses the next URL in the list.
 */
export type LoadBalancingStrategy = "NONE" | "ROUND_ROBIN" | "ONE_RANDOM";

/**
 * An arbitrary object with string values representing HTTP headers and their
 * values.
 *
 * Header names should always be lowercase.
 */
export type Headers = {
  [key: string]: string;
};

/**
 * An arbitrary object with scalar values representing query string parameters
 * and their values.
 */
export type Params = {
  [key: string]: any;
};

/**
 * Generic properties shared by all ArangoDB HTTP API responses.
 */
export type ArangoResponseMetadata = {
  /**
   * Indicates that the request was successful.
   */
  error: false;
  /**
   * The response status code, typically `200`.
   */
  code: number;
};

function clean<T>(obj: T) {
  const result = {} as typeof obj;

  for (const key of Object.keys(obj)) {
    const value = (obj as any)[key];

    if (value === undefined) {
      continue;
    }

    (result as any)[key] = value;
  }

  return result;
}

/**
 * Credentials for HTTP Basic authentication.
 */
export type BasicAuth = {
  /**
   * The username, e.g. `"root"`.
   */
  username: string;
  /**
   * The password. Defaults to an empty string.
   */
  password?: string;
};

/**
 * Credentials for HTTP Bearer token authentication.
 */
export type BearerAuth = {
  /**
   * The Bearer token.
   */
  token: string;
};

function isBearerAuth(auth: any): auth is BearerAuth {
  return auth.hasOwnProperty("token");
}

type UrlInfo = {
  absolutePath?: boolean;
  basePath?: string;
  path?: string;
  qs?: string | Params;
};

/**
 * Options for performing a request with arangojs.
 */
export type RequestOptions = {
  /**
   * @internal
   *
   * Identifier of a specific ArangoDB host to use when more than one is known.
   */
  host?: number;
  /**
   * HTTP method to use in order to perform the request.
   *
   * Default: `"GET"`
   */
  method?: string;
  /**
   * Request body data.
   */
  body?: any;
  /**
   * If set to `true`, the response body will not be interpreted as JSON and
   * instead passed as-is.
   */
  expectBinary?: boolean;
  /**
   * If set to `true`, the request body will not be converted to JSON and
   * instead passed as-is.
   */
  isBinary?: boolean;
  /**
   * Whether ArangoDB is allowed to perform a dirty read to respond to this
   * request. If set to `true`, the response may reflect a dirty state from
   * a non-authoritative server.
   */
  allowDirtyRead?: boolean;
  /**
   * HTTP headers to pass along with this request in addition to the default
   * headers generated by arangojs.
   */
  headers?: Headers;
  /**
   * Time in milliseconds after which arangojs will abort the request if the
   * socket has not already timed out.
   *
   * See also `agentOptions.timeout` in {@link Config}.
   */
  timeout?: number;
  /**
   * Optional prefix path to prepend to the `path`.
   */
  basePath?: string;
  /**
   * URL path, relative to the `basePath` and server domain.
   */
  path?: string;
  /**
   * URL parameters to pass as part of the query string.
   */
  qs?: string | Params;
};

type Task = {
  host?: number;
  allowDirtyRead: boolean;
  resolve: Function;
  reject: Function;
  retries: number;
  options: {
    method: string;
    expectBinary: boolean;
    timeout?: number;
    url: { pathname: string; search?: string };
    headers: Headers;
    body: any;
  };
};

/**
 * Options for configuring arangojs.
 */
export type Config = {
  /**
   * Name of the database to use.
   *
   * Default: `"_system"`
   */
  databaseName?: string;
  /**
   * Base URL of the ArangoDB server or list of server URLs.
   *
   * When working with a cluster or a single server with leader/follower
   * failover, the method {@link Database.acquireHostList} can be used to
   * automatically pick up additional coordinators/followers at any point.
   *
   * When running ArangoDB on a unix socket, e.g. `/tmp/arangodb.sock`, the
   * following URL formats are supported for unix sockets:
   *
   * - `unix:///tmp/arangodb.sock` (no SSL)
   * - `http+unix:///tmp/arangodb.sock` (or `https+unix://` for SSL)
   * - `http://unix:/tmp/arangodb.sock` (or `https://unix:` for SSL)
   *
   * Additionally `ssl` and `tls` are treated as synonymous with `https` and
   * `tcp` is treated as synonymous with `http`, so the following URLs are
   * considered identical:
   *
   * - `tcp://localhost:8529` and `http://localhost:8529`
   * - `ssl://localhost:8529` and `https://localhost:8529`
   * - `tcp+unix:///tmp/arangodb.sock` and `http+unix:///tmp/arangodb.sock`
   * - `ssl+unix:///tmp/arangodb.sock` and `https+unix:///tmp/arangodb.sock`
   * - `tcp://unix:/tmp/arangodb.sock` and `http://unix:/tmp/arangodb.sock`
   * - `ssl://unix:/tmp/arangodb.sock` and `https://unix:/tmp/arangodb.sock`
   *
   * See also `auth` for passing authentication credentials.
   *
   * Default: `"http://localhost:8529"`
   */
  url?: string | string[];
  /**
   * Credentials to use for authentication.
   *
   * See also {@link Database.useBasicAuth} and {@link Database.useBearerAuth}.
   *
   * Default: `{ username: "root", password: "" }`
   */
  auth?: BasicAuth | BearerAuth;
  /**
   * Numeric representation of the ArangoDB version the driver should expect.
   * The format is defined as `XYYZZ` where `X` is the major version, `Y` is
   * the zero-filled two-digit minor version and `Z` is the zero-filled two-digit
   * bugfix version, e.g. `30102` for 3.1.2, `20811` for 2.8.11.
   *
   * Depending on this value certain methods may become unavailable or change
   * their behavior to remain compatible with different versions of ArangoDB.
   *
   * Default: `30400`
   */
  arangoVersion?: number;
  /**
   * Determines the behavior when multiple URLs are provided:
   *
   * - `"NONE"`: No load balancing. All requests will be handled by the first
   *   URL in the list until a network error is encountered. On network error,
   *   arangojs will advance to using the next URL in the list.
   *
   * - `"ONE_RANDOM"`: Randomly picks one URL from the list initially, then
   *   behaves like `"NONE"`.
   *
   * - `"ROUND_ROBIN"`: Every sequential request uses the next URL in the list.
   *
   * Default: `"NONE"`
   */
  loadBalancingStrategy?: LoadBalancingStrategy;
  /**
   * Determines the behavior when a request fails because the underlying
   * connection to the server could not be opened
   * (i.e. {@link https://nodejs.org/api/errors.html#errors_common_system_errors | `ECONNREFUSED` in Node.js}):
   *
   * - `false`: the request fails immediately.
   *
   * - `0`: the request is retried until a server can be reached but only a
   *   total number of times matching the number of known servers (including
   *   the initial failed request).
   *
   * - any other number: the request is retried until a server can be reached
   *   the request has been retried a total of `maxRetries` number of times
   *   (not including the initial failed request).
   *
   * When working with a single server without leader/follower failover, the
   * retries (if any) will be made to the same server.
   *
   * This setting currently has no effect when using arangojs in a browser.
   *
   * **Note**: Requests bound to a specific server (e.g. fetching query results)
   * will never be retried automatically and ignore this setting.
   *
   * Default: `0`
   */
  maxRetries?: false | number;

  /**
   * Options used to create that underlying HTTP/HTTPS `Agent`.
   *
   * The option `maxSockets` can also be used to limit how many requests
   * arangojs will perform concurrently. The maximum number of requests is
   * equal to `maxSockets * 2` with `keepAlive: true` or equal to `maxSockets`
   * with `keepAlive: false` (or in the browser).
   *
   * @TODO
   */
  agentOptions?: {};
  /**
   * An object with additional headers to send with every request.
   *
   * If an `"authorization"` header is provided, it will be overridden when
   * using {@link Database.useBasicAuth}, {@link Database.useBearerAuth} or
   * the `auth` configuration option.
   */
  headers?: Headers;
};

/**
 * Indicates whether the given value represents a {@link Connection}.
 *
 * @param connection - A value that might be a connection.
 *
 * @internal
 * @hidden
 */
export function isArangoConnection(connection: any): connection is Connection {
  return Boolean(connection && connection.isArangoConnection);
}

/**
 * Represents a connection pool shared by one or more databases.
 *
 * @internal
 * @hidden
 */
export class Connection {
  protected _activeTasks: number = 0;
  protected _agentOptions: { [key: string]: any };
  protected _arangoVersion: number = 30400;
  protected _headers: Headers;
  protected _loadBalancingStrategy: LoadBalancingStrategy;
  protected _useFailOver: boolean;
  protected _shouldRetry: boolean;
  protected _maxRetries: number;
  protected _maxTasks: number;
  protected _queue = new Array<Task>();
  protected _databases = new Map<string, Database>();
  protected _hosts: RequestFunction[] = [];
  protected _urls: string[] = [];
  protected _activeHost: number;
  protected _activeDirtyHost: number;
  protected _transactionId: string | null = null;

  /**
   * @internal
   *
   * Creates a new `Connection` instance.
   *
   * @param config - An object with configuration options.
   *
   * @hidden
   */
  constructor(config: Omit<Config, "databaseName"> = {}) {
    if (config.arangoVersion !== undefined) {
      this._arangoVersion = config.arangoVersion;
    }

    this._agentOptions = {
      maxSockets: 3,
      keepAlive: true,
      keepAliveMsecs: 1000,
      ...config.agentOptions,
    };
    this._maxTasks = this._agentOptions.maxSockets;

    if (this._agentOptions.keepAlive) {
      this._maxTasks *= 2;
    }

    this._headers = { ...config.headers };
    this._loadBalancingStrategy = config.loadBalancingStrategy || "NONE";
    this._useFailOver = this._loadBalancingStrategy !== "ROUND_ROBIN";

    if (config.maxRetries === false) {
      this._shouldRetry = false;
      this._maxRetries = 0;
    } else {
      this._shouldRetry = true;
      this._maxRetries = config.maxRetries || 0;
    }

    const urls = config.url
      ? Array.isArray(config.url) ? config.url : [config.url]
      : ["http://localhost:8529"];

    this.addToHostList(urls);

    if (config.auth) {
      if (isBearerAuth(config.auth)) {
        this.setBearerAuth(config.auth);
      } else {
        this.setBasicAuth(config.auth);
      }
    }

    if (this._loadBalancingStrategy === "ONE_RANDOM") {
      this._activeHost = Math.floor(Math.random() * this._hosts.length);
      this._activeDirtyHost = Math.floor(Math.random() * this._hosts.length);
    } else {
      this._activeHost = 0;
      this._activeDirtyHost = 0;
    }
  }

  /**
   * @internal
   *
   * Indicates that this object represents an ArangoDB connection.
   */
  get isArangoConnection(): true {
    return true;
  }

  protected _runQueue() {
    if (!this._queue.length || this._activeTasks >= this._maxTasks) {
      return;
    }

    const task = this._queue.shift()!;

    let host = this._activeHost;

    if (task.host !== undefined) {
      host = task.host;
    } else if (task.allowDirtyRead) {
      host = this._activeDirtyHost;

      this._activeDirtyHost = (this._activeDirtyHost + 1) % this._hosts.length;

      task.options.headers["x-arango-allow-dirty-read"] = "true";
    } else if (this._loadBalancingStrategy === "ROUND_ROBIN") {
      this._activeHost = (this._activeHost + 1) % this._hosts.length;
    }

    this._activeTasks += 1;

    const callback: Errback<ArangojsResponse> = (err, res) => {
      this._activeTasks -= 1;

      if (err) {
        if (
          !task.allowDirtyRead &&
          this._hosts.length > 1 &&
          this._activeHost === host &&
          this._useFailOver
        ) {
          this._activeHost = (this._activeHost + 1) % this._hosts.length;
        }

        if (
          !task.host &&
          this._shouldRetry &&
          task.retries < (this._maxRetries || this._hosts.length - 1) &&
          isSystemError(err) &&
          err.syscall === "connect" &&
          err.code === "ECONNREFUSED"
        ) {
          task.retries += 1;

          this._queue.push(task);
        } else {
          task.reject(err);
        }
      } else {
        const response = res! as ArangojsResponse;

        if (
          response.status === 503 &&
          response.headers.has(LEADER_ENDPOINT_HEADER)
        ) {
          const url = response.headers.get(LEADER_ENDPOINT_HEADER)!;
          const [index] = this.addToHostList(url);

          task.host = index;

          if (this._activeHost === host) {
            this._activeHost = index;
          }

          this._queue.push(task);
        } else {
          response.arangojsHostId = host;
          task.resolve(response);
        }
      }

      this._runQueue();
    };

    try {
      this._hosts[host](task.options, callback);
    } catch (e) {
      callback(e);
    }
  }

  protected _buildUrl({ basePath, path, qs }: UrlInfo) {
    const pathname = `${basePath || ""}${path || ""}`;
    let search;

    if (qs) {
      if (typeof qs === "string") {
        search = `?${qs}`;
      } else {
        search = `?${Querystring.stringify(clean(qs))}`;
      }
    }

    return search ? { pathname, search } : { pathname };
  }

  setBearerAuth(auth: BearerAuth) {
    this.setHeader("authorization", `Bearer ${auth.token}`);
  }

  setBasicAuth(auth: BasicAuth) {
    this.setHeader(
      "authorization",
      `Basic ${
        btoa(unescape(encodeURIComponent(`${auth.username}:${auth.password}`)))
      }`,
    );
  }

  /**
   * @internal
   *
   * Fetches a {@link Database} instance for the given database name from the
   * internal cache, if available.
   *
   * @param databaseName - Name of the database.
   */
  database(databaseName: string): Database | undefined;

  /**
   * @internal
   *
   * Adds a {@link Database} instance for the given database name to the
   * internal cache.
   *
   * @param databaseName - Name of the database.
   * @param database - Database instance to add to the cache.
   */
  database(databaseName: string, database: Database): Database;

  /**
   * @internal
   *
   * Clears any {@link Database} instance stored for the given database name
   * from the internal cache, if present.
   *
   * @param databaseName - Name of the database.
   * @param database - Must be `null`.
   */
  database(databaseName: string, database: null): undefined;

  database(
    databaseName: string,
    database?: Database | null,
  ): Database | undefined {
    if (database === null) {
      this._databases.delete(databaseName);

      return undefined;
    }

    if (!database) {
      return this._databases.get(databaseName);
    }

    this._databases.set(databaseName, database);

    return database;
  }

  /**
   * @internal
   *
   * Adds the given URL or URLs to the host list.
   *
   * See {@link Connection.acquireHostList}.
   *
   * @param urls - URL or URLs to add.
   */
  addToHostList(urls: string | string[]): number[] {
    const cleanUrls = (Array.isArray(urls) ? urls : [urls]).map((url) =>
      sanitizeUrl(url)
    );
    const newUrls = cleanUrls.filter((url) => this._urls.indexOf(url) === -1);

    this._urls.push(...newUrls);
    this._hosts.push(
      ...newUrls.map((url: string) => createRequest(url, this._agentOptions)),
    );

    return cleanUrls.map((url) => this._urls.indexOf(url));
  }

  /**
   * @internal
   *
   * Sets the connection's active `transactionId`.
   *
   * While set, all requests will use this ID, ensuring the requests are executed
   * within the transaction if possible. Setting the ID manually may cause
   * unexpected behavior.
   *
   * See {@link Connection.clearTransactionId}.
   *
   * @param transactionId - ID of the active transaction.
   */
  setTransactionId(transactionId: string) {
    this._transactionId = transactionId;
  }

  /**
   * @internal
   *
   * Clears the connection's active `transactionId`.
   */
  clearTransactionId() {
    this._transactionId = null;
  }

  /**
   * @internal
   *
   * Sets the header `headerName` with the given `value` or clears the header if
   * `value` is `null`.
   *
   * @param headerName - Name of the header to set.
   * @param value - Value of the header.
   */
  setHeader(headerName: string, value: string | null) {
    if (value === null) {
      delete this._headers[headerName];
    } else {
      this._headers[headerName] = value;
    }
  }

  /**
   * @internal
   *
   * Closes all open connections.
   *
   * See {@link Database.close}.
   */
  close() {
    for (const host of this._hosts) {
      if (host.close) {
        host.close();
      }
    }
  }

  /**
   * @internal
   *
   * Performs a request using the arangojs connection pool.
   */
  public request<T = ArangojsResponse>(
    {
      host,
      method = "GET",
      body,
      expectBinary = false,
      isBinary = false,
      allowDirtyRead = false,
      timeout = 0,
      headers,
      ...urlInfo
    }: RequestOptions,
    transform?: (res: ArangojsResponse) => T,
  ): Promise<T> {
    return new Promise((resolve, reject) => {
      const extraHeaders: Headers = {
        ...this._headers,
        "x-arango-version": String(this._arangoVersion),
      };

      if (isBinary) {
        extraHeaders["Accept"] = "application/octet-stream";
        extraHeaders["Content-Type"] = "application/octet-stream";
      }

      if (this._transactionId) {
        extraHeaders["x-arango-trx-id"] = this._transactionId;
      }

      this._queue.push({
        retries: 0,
        host,
        allowDirtyRead,
        options: {
          url: this._buildUrl(urlInfo),
          headers: { ...extraHeaders, ...headers },
          timeout,
          method,
          expectBinary,
          body,
        },
        reject,
        resolve: async (res: ArangojsResponse) => {
          const contentType = res.headers.get("content-type");

          let parsedBody: any = undefined;

          if (
            res.body !== null && contentType && contentType.match(MIME_JSON)
          ) {
            try {
              parsedBody = await res.json();
            } catch (e) {
              if (!expectBinary) {
                e.response = res;

                reject(e);

                return;
              }
            }
          } else if (res.body && !expectBinary) {
            parsedBody = await res.json();
          } else {
            parsedBody = await res.formData.toString();
          }

          if (
            parsedBody &&
            parsedBody.hasOwnProperty("error") &&
            parsedBody.hasOwnProperty("code") &&
            parsedBody.hasOwnProperty("errorMessage") &&
            parsedBody.hasOwnProperty("errorNum")
          ) {
            reject(new ArangoError({ ...res, data: parsedBody }));
          } else if (res.status && res.status >= 300) {
            reject(new HttpError({ ...res, data: parsedBody }));
          } else {
            if (!expectBinary) {
              res.data = parsedBody;
            }

            resolve(transform ? transform(res) : (res as any));
          }
        },
      });

      this._runQueue();
    });
  }
}
